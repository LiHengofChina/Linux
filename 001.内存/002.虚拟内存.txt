
内存的一项主要任务，就是存储进程的相关数据。
我们之前已经看到过进程空间的程序段、全局数据、栈和堆，
以及这些这些存储结构在进程运行中所起到的关键作用

//===============================================================================
//===============================================================================
	有趣的是，尽管进程和内存的关系如此紧密，但"进程并不能直接访问内存"。
	在Linux下，进程不能直接读写内存中地址为0x1位置的数据。
	进程中能访问的地址，只能是"虚拟内存地址（virtual memory address）"。
	操作系统会把"虚拟内存地址"翻译成"真实内存地址"。
	这种内存管理方式，称为虚拟内存（virtual memory）。
	
	//===============================================
	//===============================================
	每个进程都有自己的"一套虚拟内存地址"，用来给自己的进程空间编号。
	进程空间的数据同样以字节为单位，依次增加。
	
	从功能上说，虚拟内存地址和物理内存地址类似，都是为数据提供位置索引。
	进程的"虚拟内存地址"相互独立。
	因此，两个进程空间可以有相同的虚拟内存地址，如0x10001000。
	
	虚拟内存地址和物理内存地址又有一定的对应关系，
	对"进程某个 '虚拟内存地址' "的操作，会被" 'CPU' 翻译成对 '某个具体内存地址' "的操作。
	/**
		'应用程序' 对 '物理内存地址' 一无所知。
		它只可能通过'虚拟内存'地址来进行'数据读写'。
		程序中表达的'内存地址'，也都是'虚拟内存地址'。
						//原来这就是真相
		"进程对虚拟内存地址的操作"，会被操作系统"翻译成对某个物理内存地址的操作"。
		由于翻译的过程由操作系统全权负责，所以应用程序可以在全过程中对物理内存地址一无所知。
	*/
	
	/**
		因此，C程序中表达的内存地址，都是虚拟内存地址。
		比如在C语言中，可以用下面指令来打印变量地址：
		int v = 0;
		printf("%p", (void*)&v);
	*/

	//===============================================================================
	//===============================================================================
		
	本质上说，虚拟内存地址剥夺了应用程序自由访问物理内存地址的权利。
	进程对物理内存的访问，必须经过操作系统的审查。
	因此，掌握着"内存对应关系"的"操作系统"，也掌握了应用程序访问内存的闸门。
	
	//=========================
	//=========================
	借助虚拟内存地址，操作系统可以保障进程空间的独立性
	只要操作系统"把两个进程的进程空间"对应到不同的"内存区域"，
	就让两个进程空间成为"老死不相往来"的"两个小王国"。
	两个进程就"不可能相互篡改对方的数据"，进程出错的可能性就大为减少。
	
	//========================= 内存共享
	//========================= 内存共享
	有了"虚拟内存地址"，内存共享也变得简单。
	操作系统可以把"同一物理内存区域"对应到多个"进程空间"。
	这样，不需要任何的数据复制，多个进程就可以看到相同的数据。
		/**
			内核和共享库的映射，就是通过这种方式进行的。
			每个进程空间中，最初一部分的虚拟内存地址，都对应到物理内存中预留给内核的空间。
			这样，所有的进程就可以共享同一套内核数据。共享库的情况也是类似。
		
			对于任何一个共享库，计算机只需要往物理内存中加载一次，
			就可以通过操纵对应关系，来让多个进程共同使用。
			IPO中的共享内存，也有赖于虚拟内存地址。		
		*/

	
