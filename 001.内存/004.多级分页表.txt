
	"内存分页制度"的关键，在于管理"进程空间页"和"物理页"的"对应关系"。
	操作系统把"对应关系"记录在"分页表（page table）"中。
	
	这种对应关系让"上层的抽象内存"和"下层的物理内存"分离，从而让Linux能灵活地进行内存管理。
	
	
	由于每个进程会有"一套虚拟'内存地址'"，
	那么"每个进程"都会有一个"分页表"。
	
	为了"保证查询速度"，"分页表"也会保存在"内存中"。
	"分页表"有很多种"实现方式"，
	
//=============================================================================== (连续分页表)线性分页表
//=============================================================================== (连续分页表)线性分页表

	最简单的一种"分页表"就是"把所有的 '对应关系' 记录到 '同一个线性列表' 中"，
			//即"对应关系"部分所示。
			//PS：从0开始，每次增加1。线性增加进行存储
		
	这种单一的"连续分页表"，需要给每一个"虚拟页"预留一条记录的位置。
	但对于任何一个应用进程，其进程空间真正用到的地址都相当有限。
	
	我们还记得，进程空间会有栈和堆。进程空间为栈和堆的增长预留了地址，但栈和堆很少会占满进程空间。
	这意味着，如果使用连续分页表，很多条目都没有真正用到。		
	

//=============================================================================== 多级分页表
//=============================================================================== 多级分页表
   
    

https://www.cnblogs.com/vamei/p/9329278.html
https://www.cnblogs.com/yelongsan/p/9353393.html
https://blog.csdn.net/henzox/article/details/41957891

