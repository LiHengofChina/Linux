	"内存分页制度"的关键，在于管理"进程空间页"和"物理页"的"对应关系"。
	操作系统把"对应关系"记录在"分页表（page table）"中。
	
	这种对应关系让"上层的抽象内存"和"下层的物理内存"分离，从而让Linux能灵活地进行内存管理。
	
	
	由于每个进程会有"一套'虚拟内存地址'"，
	那么"每个进程"都会有一个"分页表"。
	
	为了"保证查询速度"，"分页表"也会保存在"内存中"。
	"分页表"有很多种"实现方式"，
	
//=============================================================================== (连续分页表)线性分页表
//=============================================================================== (连续分页表)线性分页表

	最简单的一种"分页表"就是"把所有的 '对应关系' 记录到 '同一个线性列表' 中"，
			//即前例的"对应关系"部分所示。
			//PS：从0开始，每次增加1。线性增加进行存储
		
	这种单一的"连续分页表"，需要给每一个"虚拟页"预留一条记录的位置。
	但对于任何一个应用进程，其进程空间真正用到的地址都相当有限。
	
	我们还记得，进程空间会有栈和堆。"进程空间"为"栈和堆的增长"预留了"地址"，
	但"栈和堆"很少会"占满进程空间"。
	这意味着，如果使用连续分页表，很多条目都没有真正用到。		
	   

//=============================================================================== 多级分页表
//=============================================================================== 多级分页表
   
    Linux中的分页表，采用了 "多层的数据结构" 。"多层的分页表" 能够减少 "所需的空间" 。
	
	//======================"多层分页表"的"简化的分页设计"示例：
	//======================"多层分页表"的"简化的分页设计"示例：
	
		我们把地址分为了页编号和偏移量两部分
		
		使用"单层分页表"的时候，用"单层的分页表"记录"页编号部分"的对应关系。
		
		使用"多层分页表"的时候，
		会进一步"分割页编号"为"两个或更多"的部分，
		然后用"两层或更多层"的"分页表"来记录其对应关系。
		
		//=============================="两分页表"	示例
		//=============================="两分页表"	示例
		"页编号"分成了"两级"：
				第一级对应了前8位"页编号"	//用2个十六进制数字表示。
				第二级对应了后12位"页编号"	//用3个十六进制编号。
							//"二级表"记录有对应的物理页，即保存了真正的分页记录。
							//"二级表"有很多张，每个二级表分页记录对应的虚拟地址前8位都相同。
							//比如二级表0x00，里面记录的前8位都是0x00。
				//============翻译过程
				//============翻译过程
				翻译地址的过程要跨越两级。
				1). 我们先取地址的前8位，在一级表中找到"对应记录"。
					"该记录"会告诉我们，"目标二级表"在内存中的"位置"。
						//PS:说明一级表存储的是二级表在内存中的位置
						//key为 二表名字，value 为它的位置。
				2). 我们再在二级表中，通过虚拟地址的后12位，找到分页记录，
					从而最终找到物理地址。	
						//PS:二级表中存的是"虚拟地址的页编号"和"物理地址的页编号"的对应关系。
						//PS:个人理解
						//key是 	"页编号前8位"+"页编号后12位"
						//value是   物理地址的完整编号
					下一步才根据"完整物理地址页编号"找到偏移位置//这里也可能分为两级
					
				
	//====================== 多层分页表的优点
	//====================== 多层分页表的优点
	1). 多层分页表就好像把完整的电话号码分成区号。
		我们把同一地区的电话号码以及对应的人名记录同通一个小本子上。
		再用一个上级本子记录区号和各个小本子的对应关系。
		如果某个区号没有使用，那么我们只需要在上级本子上把该区号标记为空。
		同样，一级分页表中0x01记录为空，说明了以0x01开头的虚拟地址段没有使用，
		相应的二级表就不需要存在。
		正是通过这一手段，多层分页表占据的空间要比单层分页表少了很多。
	2). 
		多层分页表还有另一个优势。
		单层分页表必须存在于连续的内存空间。
		而多层分页表的二级表，可以散步于内存的不同位置。
		这样的话，操作系统就可以利用零碎空间来存储分页表。
		还需要注意的是，这里简化了多层分页表的很多细节。
		最新Linux系统中的分页表多达3层，管理的内存地址也比本章介绍的长很多。
		不过，多层分页表的基本原理都是相同。
		