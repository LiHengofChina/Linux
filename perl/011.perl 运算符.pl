#!/usr/bin/perl

print("\n_________________________________算术运算符__________________________________________________\n");
=pod
      +	 -  *   /	% 
	  **	乘幂	  $a**$b 结果为 10 的 20 次方
=cut
 
print("\n_________________________________比较运算符(数字)__________________________________________________\n");

=pod
    == 		!=		> 		<	  >=	  <=	 
    
	<=>	  相当于java的comparTo
    
=cut
print("\n_________________________________比较运算符(字符串)__________________________________________________\n");

=pod
	 和上面相同，只是这部分是用来比较字符串的
      lt	<
      gt	>
      le	<=
      ge	>=
      eq	==
      ne	!=
      cmp	compareTo

=cut

print("\n_________________________________赋值运算符__________________________________________________\n");

=pod
      =
      +=
      -=
      *=
      /=
      %=
      **=
=cut

print("\n_________________________________位运算(数字)__________________________________________________\n");

=pod
	&	如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	($a & $b) 将得到 12，二进制为 0000 1100
	|	如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	($a | $b) 将得到 61 ，二进制为 0011 1101
	^	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。	($a ^ $b) 将得到 49，二进制为 0011 0001
	~	二进制反码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。	(~$a ) 将得到 -61 ，二进制为 1100 0011 ，一个有符号二进制数的反码形式。
	<<	二进制左移运算符。左操作数的值向左移动右操作数指定的位数。	$a << 2 将得到 240 ，二进制为 1111 0000
	>>
=cut

use integer;

$a = 60;
$b = 13;
 
print "\$a = $a , \$b = $b\n";

$c = $a & $b;
print "\$a & \$b = $c\n";

$c = $a | $b;
print "\$a | \$b = $c\n";
 
$c = $a ^ $b;
print "\$a ^ \$b = $c\n";
 
$c = ~$a;
print "~\$a = $c\n";
 
$c = $a << 2;
print "\$a << 2 = $c\n";
 
$c = $a >> 2;
print "\$a >> 2 = $c\n";

print("\n_________________________________逻辑运算符__________________________________________________\n");

=pod
	and			 ($a and $b) 为 false。
	&&			 ($a && $b)  为 false。
	or			 ($a or $b)  为 true。
	||			 ($a || $b)  为 true。
	not
=cut





